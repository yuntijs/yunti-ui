!(function(){"use strict";var le=Object.defineProperty,fe=Object.defineProperties;var ue=Object.getOwnPropertyDescriptors;var $=Object.getOwnPropertySymbols;var ge=Object.prototype.hasOwnProperty,we=Object.prototype.propertyIsEnumerable;var L=(E,M,u)=>M in E?le(E,M,{enumerable:!0,configurable:!0,writable:!0,value:u}):E[M]=u,G=(E,M)=>{for(var u in M||(M={}))ge.call(M,u)&&L(E,u,M[u]);if($)for(var u of $(M))we.call(M,u)&&L(E,u,M[u]);return E},I=(E,M)=>fe(E,ue(M));var O=(E,M,u)=>new Promise((p,A)=>{var N=b=>{try{R(u.next(b))}catch(Z){A(Z)}},J=b=>{try{R(u.throw(b))}catch(Z){A(Z)}},R=b=>b.done?p(b.value):Promise.resolve(b.value).then(N,J);R((u=u.apply(E,M)).next())});(self.webpackChunk_yuntijs_ui=self.webpackChunk_yuntijs_ui||[]).push([[8376],{25043:function(E,M,u){var p=u(67062),A=4;function N(J){return(0,p.Z)(J,A)}M.Z=N},38376:function(E,M,u){u.r(M),u.d(M,{render:function(){return de}});var p=u(56843),A=u(44954),N=u(62859),J=u(73746),R=u(49597),b=u(85565),Z=u(68072),q=u(28081),s=u(99177),ee=u(88491),k=u(71180),ne=u(25043),H=u(55247),Me=u(24390);function C(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:te(e),edges:se(e)};return k.Z(e.graph())||(t.value=ne.Z(e.graph())),t}function te(e){return H.Z(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),a={v:t};return k.Z(n)||(a.value=n),k.Z(r)||(a.parent=r),a})}function se(e){return H.Z(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return k.Z(t.name)||(r.name=t.name),k.Z(n)||(r.value=n),r})}function ve(e){var t=new Graph(e.options).setGraph(e.value);return _.each(e.nodes,function(n){t.setNode(n.v,n.value),n.parent&&t.setParent(n.v,n.parent)}),_.each(e.edges,function(n){t.setEdge({v:n.v,w:n.w,name:n.name},n.value)}),t}var T=u(22123),l=new Map,D=new Map,j=new Map,ie=(0,s.eW)(()=>{D.clear(),j.clear(),l.clear()},"clear"),Y=(0,s.eW)((e,t)=>{const n=D.get(t)||[];return s.cM.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),ce=(0,s.eW)((e,t)=>{const n=D.get(t)||[];return s.cM.info("Descendants of ",t," is ",n),s.cM.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||Y(e.v,t)||Y(e.w,t)||n.includes(e.w):(s.cM.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),F=(0,s.eW)((e,t,n,r)=>{s.cM.warn("Copying children of ",e,"root",r,"data",t.node(e),r);const a=t.children(e)||[];e!==r&&a.push(e),s.cM.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(o=>{if(t.children(o).length>0)F(o,t,n,r);else{const c=t.node(o);s.cM.info("cp ",o," to ",r," with parent ",e),n.setNode(o,c),r!==t.parent(o)&&(s.cM.warn("Setting parent",o,t.parent(o)),n.setParent(o,t.parent(o))),e!==r&&o!==e?(s.cM.debug("Setting parent",o,e),n.setParent(o,e)):(s.cM.info("In copy ",e,"root",r,"data",t.node(e),r),s.cM.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==r,"node!==clusterId",o!==e));const g=t.edges(o);s.cM.debug("Copying Edges",g),g.forEach(f=>{s.cM.info("Edge",f);const X=t.edge(f.v,f.w,f.name);s.cM.info("Edge data",X,r);try{ce(f,r)?(s.cM.info("Copying as ",f.v,f.w,X,f.name),n.setEdge(f.v,f.w,X,f.name),s.cM.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.cM.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",r," clusterId:",e)}catch(P){s.cM.error(P)}})}s.cM.debug("Removing node",o),t.removeNode(o)})},"copy"),V=(0,s.eW)((e,t)=>{const n=t.children(e);let r=[...n];for(const a of n)j.set(a,e),r=[...r,...V(a,t)];return r},"extractDescendants"),re=(0,s.eW)((e,t,n)=>{const r=e.edges().filter(f=>f.v===t||f.w===t),a=e.edges().filter(f=>f.v===n||f.w===n),o=r.map(f=>({v:f.v===t?n:f.v,w:f.w===t?t:f.w})),c=a.map(f=>({v:f.v,w:f.w}));return o.filter(f=>c.some(X=>f.v===X.v&&f.w===X.w))},"findCommonEdges"),W=(0,s.eW)((e,t,n)=>{const r=t.children(e);if(s.cM.trace("Searching children of id ",e,r),r.length<1)return e;let a;for(const o of r){const c=W(o,t,n),g=re(t,n,c);if(c)if(g.length>0)a=c;else return c}return a},"findNonClusterChild"),K=(0,s.eW)(e=>!l.has(e)||!l.get(e).externalConnections?e:l.has(e)?l.get(e).id:e,"getAnchorId"),oe=(0,s.eW)((e,t)=>{if(!e||t>10){s.cM.debug("Opting out, no graph ");return}else s.cM.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.cM.warn("Cluster identified",n," Replacement id in edges: ",W(n,e,n)),D.set(n,V(n,e)),l.set(n,{id:W(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const r=e.children(n),a=e.edges();r.length>0?(s.cM.debug("Cluster identified",n,D),a.forEach(o=>{const c=Y(o.v,n),g=Y(o.w,n);c^g&&(s.cM.warn("Edge: ",o," leaves cluster ",n),s.cM.warn("Descendants of XXX ",n,": ",D.get(n)),l.get(n).externalConnections=!0)})):s.cM.debug("Not a cluster ",n,D)});for(let n of l.keys()){const r=l.get(n).id,a=e.parent(r);a!==n&&l.has(a)&&!l.get(a).externalConnections&&(l.get(n).id=a)}e.edges().forEach(function(n){const r=e.edge(n);s.cM.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.cM.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let a=n.v,o=n.w;if(s.cM.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(s.cM.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),a=K(n.v),o=K(n.w),e.removeEdge(n.v,n.w,n.name),a!==n.v){const c=e.parent(a);l.get(c).externalConnections=!0,r.fromCluster=n.v}if(o!==n.w){const c=e.parent(o);l.get(c).externalConnections=!0,r.toCluster=n.w}s.cM.warn("Fix Replacing with XXX",a,o,n.name),e.setEdge(a,o,r,n.name)}}),s.cM.warn("Adjusted Graph",C(e)),Q(e,0),s.cM.trace(l)},"adjustClustersAndEdges"),Q=(0,s.eW)((e,t)=>{var a,o;if(s.cM.warn("extractor - ",t,C(e),e.children("D")),t>10){s.cM.error("Bailing out");return}let n=e.nodes(),r=!1;for(const c of n){const g=e.children(c);r=r||g.length>0}if(!r){s.cM.debug("Done, no node has children",e.nodes());return}s.cM.debug("Nodes = ",n,t);for(const c of n)if(s.cM.debug("Extracting node",c,l,l.has(c)&&!l.get(c).externalConnections,!e.parent(c),e.node(c),e.children("D")," Depth ",t),!l.has(c))s.cM.debug("Not a cluster",c,t);else if(!l.get(c).externalConnections&&e.children(c)&&e.children(c).length>0){s.cM.warn("Cluster without external connections, without a parent and with children",c,t);let f=e.graph().rankdir==="TB"?"LR":"TB";(o=(a=l.get(c))==null?void 0:a.clusterData)!=null&&o.dir&&(f=l.get(c).clusterData.dir,s.cM.warn("Fixing dir",l.get(c).clusterData.dir,f));const X=new T.k({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.cM.warn("Old graph before copy",C(e)),F(c,e,X,c),e.setNode(c,{clusterNode:!0,id:c,clusterData:l.get(c).clusterData,label:l.get(c).label,graph:X}),s.cM.warn("New graph after copy node: (",c,")",C(X)),s.cM.debug("Old graph after copy",C(e))}else s.cM.warn("Cluster ** ",c," **not meeting the criteria !externalConnections:",!l.get(c).externalConnections," no parent: ",!e.parent(c)," children ",e.children(c)&&e.children(c).length>0,e.children("D"),t),s.cM.debug(l);n=e.nodes(),s.cM.warn("New list of nodes",n);for(const c of n){const g=e.node(c);s.cM.warn(" Now next level",c,g),g!=null&&g.clusterNode&&Q(g.graph,t+1)}},"extractor"),U=(0,s.eW)((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(r=>{const a=e.children(r),o=U(e,a);n=[...n,...o]}),n},"sorter"),ae=(0,s.eW)(e=>U(e,e.children()),"sortNodesByHierarchy"),z=(0,s.eW)((e,t,n,r,a,o)=>O(this,null,function*(){s.cM.warn("Graph in recursive render:XAX",C(t),a);const c=t.graph().rankdir;s.cM.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");t.nodes()?s.cM.info("Recursive render XXX",t.nodes()):s.cM.info("No nodes found for",t),t.edges().length>0&&s.cM.info("Recursive edges",t.edge(t.edges()[0]));const f=g.insert("g").attr("class","clusters"),X=g.insert("g").attr("class","edgePaths"),P=g.insert("g").attr("class","edgeLabels"),w=g.insert("g").attr("class","nodes");yield Promise.all(t.nodes().map(function(d){return O(this,null,function*(){const i=t.node(d);if(a!==void 0){const v=JSON.parse(JSON.stringify(a.clusterData));s.cM.trace(`Setting data for parent cluster XXX
 Node.id = `,d,`
 data=`,v.height,`
Parent cluster`,a.height),t.setNode(a.id,v),t.parent(d)||(s.cM.trace("Setting parent",d,a.id),t.setParent(d,a.id,v))}if(s.cM.info("(Insert) Node XXX"+d+": "+JSON.stringify(t.node(d))),i!=null&&i.clusterNode){s.cM.info("Cluster identified XBX",d,i.width,t.node(d));const{ranksep:v,nodesep:h}=t.graph();i.graph.setGraph(I(G({},i.graph.graph()),{ranksep:v+25,nodesep:h}));const x=yield z(w,i.graph,n,r,t.node(d),o),B=x.elem;(0,N.jr)(i,B),i.diff=x.diff||0,s.cM.info("New compound node after recursive render XAX",d,"width",i.width,"height",i.height),(0,N.Yn)(B,i)}else t.children(d).length>0?(s.cM.trace("Cluster - the non recursive path XBX",d,i.id,i,i.width,"Graph:",t),s.cM.trace(W(i.id,t)),l.set(i.id,{id:W(i.id,t),node:i})):(s.cM.trace("Node - the non recursive path XAX",d,w,t.node(d),c),yield(0,N.Lf)(w,t.node(d),{config:o,dir:c}))})})),yield(0,s.eW)(()=>O(this,null,function*(){const d=t.edges().map(function(i){return O(this,null,function*(){const v=t.edge(i.v,i.w,i.name);s.cM.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),s.cM.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),s.cM.info("Fix",l,"ids:",i.v,i.w,"Translating: ",l.get(i.v),l.get(i.w)),yield(0,p.I_)(P,v)})});yield Promise.all(d)}),"processEdges")(),s.cM.info("Graph before layout:",JSON.stringify(C(t))),s.cM.info("############################################# XXX"),s.cM.info("###                Layout                 ### XXX"),s.cM.info("############################################# XXX"),(0,ee.bK)(t),s.cM.info("Graph after layout:",JSON.stringify(C(t)));let S=0,{subGraphTitleTotalMargin:y}=(0,J.L)(o);return yield Promise.all(ae(t).map(function(d){return O(this,null,function*(){var v;const i=t.node(d);if(s.cM.info("Position XBX => "+d+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i!=null&&i.clusterNode)i.y+=y,s.cM.info("A tainted cluster node XBX1",d,i.id,i.width,i.height,i.x,i.y,t.parent(d)),l.get(i.id).node=i,(0,N.aH)(i);else if(t.children(d).length>0){s.cM.info("A pure cluster node XBX1",d,i.id,i.x,i.y,i.width,i.height,t.parent(d)),i.height+=y,t.node(i.parentId);const h=(i==null?void 0:i.padding)/2||0,x=((v=i==null?void 0:i.labelBBox)==null?void 0:v.height)||0,B=x-h||0;s.cM.debug("OffsetY",B,"labelHeight",x,"halfPadding",h),yield(0,N.us)(f,i),l.get(i.id).node=i}else{const h=t.node(i.parentId);i.y+=y/2,s.cM.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",h,h==null?void 0:h.offsetY,i),(0,N.aH)(i)}})})),t.edges().forEach(function(d){const i=t.edge(d);s.cM.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(i),i),i.points.forEach(B=>B.y+=y/2);const v=t.node(d.v);var h=t.node(d.w);const x=(0,p.QP)(X,i,l,n,v,h,r);(0,p.Jj)(i,x)}),t.nodes().forEach(function(d){const i=t.node(d);s.cM.info(d,i.type,i.diff),i.isGroup&&(S=i.diff)}),s.cM.warn("Returning from recursive render XAX",g,S),{elem:g,diff:S}}),"recursiveRender"),de=(0,s.eW)((e,t)=>O(this,null,function*(){var o,c,g,f,X,P;const n=new T.k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((o=e.config)==null?void 0:o.nodeSpacing)||((g=(c=e.config)==null?void 0:c.flowchart)==null?void 0:g.nodeSpacing)||e.nodeSpacing,ranksep:((f=e.config)==null?void 0:f.rankSpacing)||((P=(X=e.config)==null?void 0:X.flowchart)==null?void 0:P.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),r=t.select("g");(0,p.DQ)(r,e.markers,e.type,e.diagramId),(0,N.gU)(),(0,p.ZH)(),(0,N.ZH)(),ie(),e.nodes.forEach(w=>{n.setNode(w.id,G({},w)),w.parentId&&n.setParent(w.id,w.parentId)}),s.cM.debug("Edges:",e.edges),e.edges.forEach(w=>{if(w.start===w.end){const m=w.start,S=m+"---"+m+"---1",y=m+"---"+m+"---2",d=n.node(m);n.setNode(S,{domId:S,id:S,parentId:d.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(S,d.parentId),n.setNode(y,{domId:y,id:y,parentId:d.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(y,d.parentId);const i=structuredClone(w),v=structuredClone(w),h=structuredClone(w);i.label="",i.arrowTypeEnd="none",i.id=m+"-cyclic-special-1",v.arrowTypeStart="none",v.arrowTypeEnd="none",v.id=m+"-cyclic-special-mid",h.label="",d.isGroup&&(i.fromCluster=m,h.toCluster=m),h.id=m+"-cyclic-special-2",h.arrowTypeStart="none",n.setEdge(m,S,i,m+"-cyclic-special-0"),n.setEdge(S,y,v,m+"-cyclic-special-1"),n.setEdge(y,m,h,m+"-cyc<lic-special-2")}else n.setEdge(w.start,w.end,G({},w),w.id)}),s.cM.warn("Graph at first:",JSON.stringify(C(n))),oe(n),s.cM.warn("Graph after XAX:",JSON.stringify(C(n)));const a=(0,q.nV)();yield z(r,n,e.type,e.diagramId,void 0,a)}),"render")}}]);
}());