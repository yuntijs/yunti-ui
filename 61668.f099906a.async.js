!(function(){"use strict";var de=Object.defineProperty,le=Object.defineProperties;var fe=Object.getOwnPropertyDescriptors;var $=Object.getOwnPropertySymbols;var ue=Object.prototype.hasOwnProperty,ge=Object.prototype.propertyIsEnumerable;var I=(X,M,u)=>M in X?de(X,M,{enumerable:!0,configurable:!0,writable:!0,value:u}):X[M]=u,H=(X,M)=>{for(var u in M||(M={}))ue.call(M,u)&&I(X,u,M[u]);if($)for(var u of $(M))ge.call(M,u)&&I(X,u,M[u]);return X},L=(X,M)=>le(X,fe(M));var P=(X,M,u)=>new Promise((b,N)=>{var A=D=>{try{k(u.next(D))}catch(R){N(R)}},Z=D=>{try{k(u.throw(D))}catch(R){N(R)}},k=D=>D.done?b(D.value):Promise.resolve(D.value).then(A,Z);k((u=u.apply(X,M)).next())});(self.webpackChunk_yuntijs_ui=self.webpackChunk_yuntijs_ui||[]).push([[61668],{25043:function(X,M,u){var b=u(67062),N=4;function A(Z){return(0,b.Z)(Z,N)}M.Z=A},61668:function(X,M,u){u.r(M),u.d(M,{render:function(){return ae}});var b=u(4638),N=u(52121),A=u(81295),Z=u(99858),k=u(73395),D=u(17549),R=u(35934),s=u(95895),q=u(94303),J=u(71180),ee=u(25043),T=u(55247),we=u(24390);function C(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ne(e),edges:te(e)};return J.Z(e.graph())||(t.value=ee.Z(e.graph())),t}function ne(e){return T.Z(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),a={v:t};return J.Z(n)||(a.value=n),J.Z(r)||(a.parent=r),a})}function te(e){return T.Z(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return J.Z(t.name)||(r.name=t.name),J.Z(n)||(r.value=n),r})}function Me(e){var t=new Graph(e.options).setGraph(e.value);return _.each(e.nodes,function(n){t.setNode(n.v,n.value),n.parent&&t.setParent(n.v,n.parent)}),_.each(e.edges,function(n){t.setEdge({v:n.v,w:n.w,name:n.name},n.value)}),t}var Y=u(22123),l=new Map,p=new Map,F=new Map,se=(0,s.eW)(()=>{p.clear(),F.clear(),l.clear()},"clear"),G=(0,s.eW)((e,t)=>{const n=p.get(t)||[];return s.cM.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),ie=(0,s.eW)((e,t)=>{const n=p.get(t)||[];return s.cM.info("Descendants of ",t," is ",n),s.cM.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||G(e.v,t)||G(e.w,t)||n.includes(e.w):(s.cM.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),j=(0,s.eW)((e,t,n,r)=>{s.cM.warn("Copying children of ",e,"root",r,"data",t.node(e),r);const a=t.children(e)||[];e!==r&&a.push(e),s.cM.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(o=>{if(t.children(o).length>0)j(o,t,n,r);else{const c=t.node(o);s.cM.info("cp ",o," to ",r," with parent ",e),n.setNode(o,c),r!==t.parent(o)&&(s.cM.warn("Setting parent",o,t.parent(o)),n.setParent(o,t.parent(o))),e!==r&&o!==e?(s.cM.debug("Setting parent",o,e),n.setParent(o,e)):(s.cM.info("In copy ",e,"root",r,"data",t.node(e),r),s.cM.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==r,"node!==clusterId",o!==e));const g=t.edges(o);s.cM.debug("Copying Edges",g),g.forEach(f=>{s.cM.info("Edge",f);const E=t.edge(f.v,f.w,f.name);s.cM.info("Edge data",E,r);try{ie(f,r)?(s.cM.info("Copying as ",f.v,f.w,E,f.name),n.setEdge(f.v,f.w,E,f.name),s.cM.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.cM.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",r," clusterId:",e)}catch(O){s.cM.error(O)}})}s.cM.debug("Removing node",o),t.removeNode(o)})},"copy"),U=(0,s.eW)((e,t)=>{const n=t.children(e);let r=[...n];for(const a of n)F.set(a,e),r=[...r,...U(a,t)];return r},"extractDescendants"),ce=(0,s.eW)((e,t,n)=>{const r=e.edges().filter(f=>f.v===t||f.w===t),a=e.edges().filter(f=>f.v===n||f.w===n),o=r.map(f=>({v:f.v===t?n:f.v,w:f.w===t?t:f.w})),c=a.map(f=>({v:f.v,w:f.w}));return o.filter(f=>c.some(E=>f.v===E.v&&f.w===E.w))},"findCommonEdges"),W=(0,s.eW)((e,t,n)=>{const r=t.children(e);if(s.cM.trace("Searching children of id ",e,r),r.length<1)return e;let a;for(const o of r){const c=W(o,t,n),g=ce(t,n,c);if(c)if(g.length>0)a=c;else return c}return a},"findNonClusterChild"),K=(0,s.eW)(e=>!l.has(e)||!l.get(e).externalConnections?e:l.has(e)?l.get(e).id:e,"getAnchorId"),re=(0,s.eW)((e,t)=>{if(!e||t>10){s.cM.debug("Opting out, no graph ");return}else s.cM.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.cM.warn("Cluster identified",n," Replacement id in edges: ",W(n,e,n)),p.set(n,U(n,e)),l.set(n,{id:W(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const r=e.children(n),a=e.edges();r.length>0?(s.cM.debug("Cluster identified",n,p),a.forEach(o=>{const c=G(o.v,n),g=G(o.w,n);c^g&&(s.cM.warn("Edge: ",o," leaves cluster ",n),s.cM.warn("Descendants of XXX ",n,": ",p.get(n)),l.get(n).externalConnections=!0)})):s.cM.debug("Not a cluster ",n,p)});for(let n of l.keys()){const r=l.get(n).id,a=e.parent(r);a!==n&&l.has(a)&&!l.get(a).externalConnections&&(l.get(n).id=a)}e.edges().forEach(function(n){const r=e.edge(n);s.cM.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.cM.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let a=n.v,o=n.w;if(s.cM.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(s.cM.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),a=K(n.v),o=K(n.w),e.removeEdge(n.v,n.w,n.name),a!==n.v){const c=e.parent(a);l.get(c).externalConnections=!0,r.fromCluster=n.v}if(o!==n.w){const c=e.parent(o);l.get(c).externalConnections=!0,r.toCluster=n.w}s.cM.warn("Fix Replacing with XXX",a,o,n.name),e.setEdge(a,o,r,n.name)}}),s.cM.warn("Adjusted Graph",C(e)),Q(e,0),s.cM.trace(l)},"adjustClustersAndEdges"),Q=(0,s.eW)((e,t)=>{var a,o;if(s.cM.warn("extractor - ",t,C(e),e.children("D")),t>10){s.cM.error("Bailing out");return}let n=e.nodes(),r=!1;for(const c of n){const g=e.children(c);r=r||g.length>0}if(!r){s.cM.debug("Done, no node has children",e.nodes());return}s.cM.debug("Nodes = ",n,t);for(const c of n)if(s.cM.debug("Extracting node",c,l,l.has(c)&&!l.get(c).externalConnections,!e.parent(c),e.node(c),e.children("D")," Depth ",t),!l.has(c))s.cM.debug("Not a cluster",c,t);else if(!l.get(c).externalConnections&&e.children(c)&&e.children(c).length>0){s.cM.warn("Cluster without external connections, without a parent and with children",c,t);let f=e.graph().rankdir==="TB"?"LR":"TB";(o=(a=l.get(c))==null?void 0:a.clusterData)!=null&&o.dir&&(f=l.get(c).clusterData.dir,s.cM.warn("Fixing dir",l.get(c).clusterData.dir,f));const E=new Y.k({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.cM.warn("Old graph before copy",C(e)),j(c,e,E,c),e.setNode(c,{clusterNode:!0,id:c,clusterData:l.get(c).clusterData,label:l.get(c).label,graph:E}),s.cM.warn("New graph after copy node: (",c,")",C(E)),s.cM.debug("Old graph after copy",C(e))}else s.cM.warn("Cluster ** ",c," **not meeting the criteria !externalConnections:",!l.get(c).externalConnections," no parent: ",!e.parent(c)," children ",e.children(c)&&e.children(c).length>0,e.children("D"),t),s.cM.debug(l);n=e.nodes(),s.cM.warn("New list of nodes",n);for(const c of n){const g=e.node(c);s.cM.warn(" Now next level",c,g),g!=null&&g.clusterNode&&Q(g.graph,t+1)}},"extractor"),V=(0,s.eW)((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(r=>{const a=e.children(r),o=V(e,a);n=[...n,...o]}),n},"sorter"),oe=(0,s.eW)(e=>V(e,e.children()),"sortNodesByHierarchy"),z=(0,s.eW)((e,t,n,r,a,o)=>P(this,null,function*(){s.cM.warn("Graph in recursive render:XAX",C(t),a);const c=t.graph().rankdir;s.cM.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");t.nodes()?s.cM.info("Recursive render XXX",t.nodes()):s.cM.info("No nodes found for",t),t.edges().length>0&&s.cM.info("Recursive edges",t.edge(t.edges()[0]));const f=g.insert("g").attr("class","clusters"),E=g.insert("g").attr("class","edgePaths"),O=g.insert("g").attr("class","edgeLabels"),w=g.insert("g").attr("class","nodes");yield Promise.all(t.nodes().map(function(d){return P(this,null,function*(){const i=t.node(d);if(a!==void 0){const h=JSON.parse(JSON.stringify(a.clusterData));s.cM.trace(`Setting data for parent cluster XXX
 Node.id = `,d,`
 data=`,h.height,`
Parent cluster`,a.height),t.setNode(a.id,h),t.parent(d)||(s.cM.trace("Setting parent",d,a.id),t.setParent(d,a.id,h))}if(s.cM.info("(Insert) Node XXX"+d+": "+JSON.stringify(t.node(d))),i!=null&&i.clusterNode){s.cM.info("Cluster identified XBX",d,i.width,t.node(d));const{ranksep:h,nodesep:m}=t.graph();i.graph.setGraph(L(H({},i.graph.graph()),{ranksep:h+25,nodesep:m}));const x=yield z(w,i.graph,n,r,t.node(d),o),B=x.elem;(0,N.jr)(i,B),i.diff=x.diff||0,s.cM.info("New compound node after recursive render XAX",d,"width",i.width,"height",i.height),(0,N.Yn)(B,i)}else t.children(d).length>0?(s.cM.trace("Cluster - the non recursive path XBX",d,i.id,i,i.width,"Graph:",t),s.cM.trace(W(i.id,t)),l.set(i.id,{id:W(i.id,t),node:i})):(s.cM.trace("Node - the non recursive path XAX",d,w,t.node(d),c),yield(0,N.Lf)(w,t.node(d),{config:o,dir:c}))})})),yield(0,s.eW)(()=>P(this,null,function*(){const d=t.edges().map(function(i){return P(this,null,function*(){const h=t.edge(i.v,i.w,i.name);s.cM.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),s.cM.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),s.cM.info("Fix",l,"ids:",i.v,i.w,"Translating: ",l.get(i.v),l.get(i.w)),yield(0,b.I_)(O,h)})});yield Promise.all(d)}),"processEdges")(),s.cM.info("Graph before layout:",JSON.stringify(C(t))),s.cM.info("############################################# XXX"),s.cM.info("###                Layout                 ### XXX"),s.cM.info("############################################# XXX"),(0,q.bK)(t),s.cM.info("Graph after layout:",JSON.stringify(C(t)));let S=0,{subGraphTitleTotalMargin:y}=(0,k.L)(o);return yield Promise.all(oe(t).map(function(d){return P(this,null,function*(){var h;const i=t.node(d);if(s.cM.info("Position XBX => "+d+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i!=null&&i.clusterNode)i.y+=y,s.cM.info("A tainted cluster node XBX1",d,i.id,i.width,i.height,i.x,i.y,t.parent(d)),l.get(i.id).node=i,(0,N.aH)(i);else if(t.children(d).length>0){s.cM.info("A pure cluster node XBX1",d,i.id,i.x,i.y,i.width,i.height,t.parent(d)),i.height+=y,t.node(i.parentId);const m=(i==null?void 0:i.padding)/2||0,x=((h=i==null?void 0:i.labelBBox)==null?void 0:h.height)||0,B=x-m||0;s.cM.debug("OffsetY",B,"labelHeight",x,"halfPadding",m),yield(0,N.us)(f,i),l.get(i.id).node=i}else{const m=t.node(i.parentId);i.y+=y/2,s.cM.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",m,m==null?void 0:m.offsetY,i),(0,N.aH)(i)}})})),t.edges().forEach(function(d){const i=t.edge(d);s.cM.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(i),i),i.points.forEach(B=>B.y+=y/2);const h=t.node(d.v);var m=t.node(d.w);const x=(0,b.QP)(E,i,l,n,h,m,r);(0,b.Jj)(i,x)}),t.nodes().forEach(function(d){const i=t.node(d);s.cM.info(d,i.type,i.diff),i.isGroup&&(S=i.diff)}),s.cM.warn("Returning from recursive render XAX",g,S),{elem:g,diff:S}}),"recursiveRender"),ae=(0,s.eW)((e,t)=>P(this,null,function*(){var o,c,g,f,E,O;const n=new Y.k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((o=e.config)==null?void 0:o.nodeSpacing)||((g=(c=e.config)==null?void 0:c.flowchart)==null?void 0:g.nodeSpacing)||e.nodeSpacing,ranksep:((f=e.config)==null?void 0:f.rankSpacing)||((O=(E=e.config)==null?void 0:E.flowchart)==null?void 0:O.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),r=t.select("g");(0,b.DQ)(r,e.markers,e.type,e.diagramId),(0,N.gU)(),(0,b.ZH)(),(0,N.ZH)(),se(),e.nodes.forEach(w=>{n.setNode(w.id,H({},w)),w.parentId&&n.setParent(w.id,w.parentId)}),s.cM.debug("Edges:",e.edges),e.edges.forEach(w=>{if(w.start===w.end){const v=w.start,S=v+"---"+v+"---1",y=v+"---"+v+"---2",d=n.node(v);n.setNode(S,{domId:S,id:S,parentId:d.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(S,d.parentId),n.setNode(y,{domId:y,id:y,parentId:d.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(y,d.parentId);const i=structuredClone(w),h=structuredClone(w),m=structuredClone(w);i.label="",i.arrowTypeEnd="none",i.id=v+"-cyclic-special-1",h.arrowTypeEnd="none",h.id=v+"-cyclic-special-mid",m.label="",d.isGroup&&(i.fromCluster=v,m.toCluster=v),m.id=v+"-cyclic-special-2",n.setEdge(v,S,i,v+"-cyclic-special-0"),n.setEdge(S,y,h,v+"-cyclic-special-1"),n.setEdge(y,v,m,v+"-cyc<lic-special-2")}else n.setEdge(w.start,w.end,H({},w),w.id)}),s.cM.warn("Graph at first:",JSON.stringify(C(n))),re(n),s.cM.warn("Graph after XAX:",JSON.stringify(C(n)));const a=(0,s.nV)();yield z(r,n,e.type,e.diagramId,void 0,a)}),"render")}}]);
}());